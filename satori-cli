#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import logging
import sys
import requests
import mimetypes
import os
import io
from pathlib import Path
from zipfile import ZipFile
import json
import shutil
import uuid
from urllib.parse import urlencode, quote_plus

from classes.resolver import get_local_imports

class Satori(object):
    """TBC"""
    def __init__(self):
        self.config_data = {}
        user_home = Path.home()
        self.config_path = f"{user_home}/.satori_credentials.json"
        self.host = "https://w7zcm8h3h1.execute-api.us-east-2.amazonaws.com/staging/"
        self.api_host = "https://nuvyp2kffa.execute-api.us-east-2.amazonaws.com/"
        # self.host = "https://api.satori-ci.com/staging/" # TODO: api.satori-ci.com

    def load_config(self):
        """TBC"""
        config_file = Path(self.config_path)
        try:
            with config_file.open() as f:
                config = f.read()
                self.config_data = json.loads(config)
        except FileNotFoundError:
            print(f"Config file not found: {config_file}")
        # Check if user token exist
        if 'token' not in self.config_data:
            print(f"Set a token with:\n{sys.argv[0]} config token \"your_user_token\"")
            sys.exit(1)

    def save_config(self, key: str, value: str):
        """TBC"""
        if value == "":
            print("Value not defined")
            return False
        if key in ('token'):  # filter config key
            self.config_data[key] = value
            config_json = json.dumps(self.config_data)
            file = open(self.config_path, 'w', 0o700)
            file.write(config_json)
            file.close()
            print('Config token updated')
        else:
            print('Unknown config setting')
            return False

    def mime_type(self, playbook):
        """Get mime type"""
        mime_type = None
        file_name = os.path.splitext(playbook)
        if file_name[1] == '.yml':
            mime_type = 'application/x-yaml'
        if mime_type is None:
            mt = mimetypes.guess_type('playbook.zip')
            mime_type = mt[0]
        #print(f"{mime_type=}")
        return mime_type

    def run(self, playbook):
        """Just run"""
        if playbook is None:
            print(f"Define the Satori playbook file:\n{sys.argv[0]} run -p playbook.yml")
            return False

        if not os.path.isfile(playbook):
            print(f"Playbook not found: {playbook}")
            return False

        bundle = io.BytesIO()

        try:
            with open(playbook) as f, ZipFile(bundle, "x") as zip:
                refs = get_local_imports(f.read(), playbook)
                zip.write(
                    playbook, "satori.yml"
                )
                for ref in refs:
                    if ref == "PLACEHOLDER":
                        continue
                    zip.write(
                        ref, f'{refs.index(ref):03d}{ref.replace("/", "-")}'
                    )
        except Exception as e:
            logging.error(e)
            return False

        self.connect(endpoint="/run", playbook="SatoriBundle.zip", data=bundle.getvalue())

    def upload(self, directory):
        """Upload directory and run"""
        temp_file = "plbk-" + str(uuid.uuid4())
        if directory is None:
            print(f"Define the directory with the Satori playbook:\n{sys.argv[0]} run -p ./directory_with_playbook")
            return False

        if os.path.isdir(directory):
            shutil.make_archive(temp_file, 'zip', directory)
            with open(temp_file + '.zip', 'rb') as f:
                data = f.read()
            os.remove(temp_file + '.zip')
        else:
            print(f"Directory not found: {directory}")
            return False

        self.connect(endpoint="/upload", playbook=directory, data=data)

    def connect(self, endpoint, playbook=None, data=None):
        """Connect to Satori API"""
        endpoint = "" # TODO: tenemos que crear los endpoints para dejar de pisarlo
        self.load_config()
        if playbook and data:
            headers = {
                "Authorization": f"token {self.config_data['token']}",
                "Content-Type": self.mime_type(playbook),
                "X-File-Name": os.path.basename(playbook)
            }
            response = requests.post(
                self.host + endpoint,
                data=data,
                headers=headers)
        elif not playbook and not data:
            headers = {
                "Authorization": f"token {self.config_data['token']}",
            }
            response = requests.get(
                self.host + endpoint,
                headers=headers)
        if response.status_code == 200:
            status = response.json()
            print(f"UUID: {status['uuid']} | URL: {status['report_url']}")
        else:
            print(f"{response.status_code = }\n{response.text = }")

    def list_playbooks(self):
        """List Satori playbooks"""
        self.connect(endpoint="/list-playbooks")

    def list_reports(self, state):
        self.load_config()
        headers = {"Authorization": f"token {self.config_data['token']}"}
        response = requests.get(f"{self.api_host}report/list/{state}",headers=headers)
        if response.status_code == 200:
            for report in response.json():
                print(f"{report['uuid']} | {report['status']}")
        else:
            print(f"{response.text = }")

    def stop_report(self, id):
        self.load_config()
        headers = {"Authorization": f"token {self.config_data['token']}"}
        response = requests.get(f"{self.api_host}report/stop/{id}",headers=headers)
        if response.status_code == 200:
            status = response.json()
            print(f"Stopped status: {status['status']}")
        else:
            print(f"{response.status_code = }\n{response.text = }")

    def report_status(self, id):
        self.load_config()
        headers = {"Authorization": f"token {self.config_data['token']}"}
        response = requests.get(f"{self.api_host}report/status/{id}",headers=headers)
        if response.status_code == 200:
            status = response.json()
            print(f"Status: {status['status']} | Fails: {status['fails']}")
        else:
            print(f"{response.status_code = }\n{response.text = }")

    def cron_action(self, action, param):
        self.load_config()
        headers = {"Authorization": f"token {self.config_data['token']}"}
        response = requests.get(f"{self.api_host}cron/{action}/{param}",headers=headers)
        if response.status_code == 200:
            if action == 'list':
                for cron in response.json():
                    print(f"ID: {cron['ID']} | Name: {cron['display_name']}")
            elif action == 'stop':
                for cron in response.json():
                    print(f"Stopped {cron['ID']}")
        else:
            print(f"{response.status_code = }\n{response.text = }")

    def scan(self, action, repo_url, coverage):
        self.load_config()
        if action not in ("start","stop","check"):
            print("Scan command not recognized")
            return
        params = urlencode({'repo':repo_url,'coverage':coverage}, quote_via=quote_plus)
        headers = {"Authorization": f"token {self.config_data['token']}"}
        response = requests.get(f"{self.api_host}scan/{action}?{params}",headers=headers)
        print(f"{response.status_code = }\n{response.text = }")

def main():
    if not (sys.version_info.major == 3 and sys.version_info.minor >= 9):
        print(f"Minimum Python version 3.9 required, the current version is {sys.version_info.major}.{sys.version_info.minor}")
        sys.exit(0)

    parser = argparse.ArgumentParser(add_help=True, exit_on_error=True)
    sub_parsers = parser.add_subparsers(dest="subcommand")

    # config token "user_token"
    config_cmd = sub_parsers.add_parser("config")
    config_cmd.add_argument("key")
    config_cmd.add_argument("value")

    # run playbook.yml
    run_cmd = sub_parsers.add_parser("run")
    run_cmd.add_argument("playbook")

    # upload ./directory
    upload_cmd = sub_parsers.add_parser("upload")
    upload_cmd.add_argument("directory")

    # list-playbooks
    list_cmd = sub_parsers.add_parser("list-playbooks")

    # list-reports state
    list_report_cmd = sub_parsers.add_parser("list-reports")
    list_report_cmd.add_argument("state", default='all', nargs='?')

    # stop-report id
    stop_report_cmd = sub_parsers.add_parser("stop-report")
    stop_report_cmd.add_argument("id")

    # status id
    status_cmd = sub_parsers.add_parser("status")
    status_cmd.add_argument("id")

    # cron list|stop <report_uuid>|stopall
    cron_cmd = sub_parsers.add_parser("cron")
    cron_cmd.add_argument("action")
    cron_cmd.add_argument("param", default='all', nargs='?')

    # scan <repo_url>
    scan_cmd = sub_parsers.add_parser("scan")
    scan_cmd.add_argument("action")
    scan_cmd.add_argument("repo_url")
    scan_cmd.add_argument('-c', type=int, default=1, help="coverage")
    
    if len(sys.argv) <= 1:
        parser.print_help()
        sys.exit(0)

    instance = Satori()
    args = parser.parse_args()
    if args.subcommand == "config":
        instance.save_config(args.key, args.value)
    elif args.subcommand == "run":
        instance.run(args.playbook)
    elif args.subcommand == "upload":
        instance.upload(args.directory)
    elif args.subcommand == "list-playbooks":
        instance.list_playbooks()
    elif args.subcommand == "list-reports":
        instance.list_reports(args.state)
    elif args.subcommand == "stop-report":
        instance.stop_report(args.id)
    elif args.subcommand == "status":
        instance.report_status(args.id)
    elif args.subcommand == "cron":
        instance.cron_action(args.action, args.param)
    elif args.subcommand == "scan":
        instance.scan(args.repo_url,args.action,args.c)

if __name__ == "__main__":
    main()
